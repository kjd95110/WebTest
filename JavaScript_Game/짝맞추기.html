<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>짝맞추기</title>
<style type="text/css">

    .card{
        display: inline-block;
        margin-right:20px;
        margin-bottom: 20px;
        width:70px;
        height:100px;
        border:1px solid black;
        perspective: 140px;
    }
    .card-inner{
        position: relative;
        width:100%;
        height:100%;
        text-align: center;
        transition: transform 0.8s;
        transform-style:preserve-3d;
    }

    .card.flipped .card-inner{
        transform: rotateY(180deg);
    }
    .card-front{
        background: navy;        
    }

    .card-front, .card-back{
        border:1px solid black;
        position:absolute;
        width:100%;
        height:100%;
        backface-visibility: hidden;
    }

    .card-back{
        background: gainsboro;
        transform: rotateY(180deg);
    }

</style>

</head> 

<body>


    <!-- <div class="card">
        <div class="card-inner">
            <div class="card-front">
                    앞
            </div>
            <div class="card-back">
                뒤
            </div>
        </div>       
    </div> -->
   <div id="wrapper"></div>
   <script src="./../js/pairSetting.js"  ></script>
   

</body>

</html> 

<!-- 

    
/* 
    var colors=candycolor; 
    array 값을 할당하면 복사가 아니라 참조관계가 성립된다.
아래 for문의 
     color= color.concat(candycolor.splice(Math.floor(Math.random() * candycolor.length) , 1));
     여기에서 colors의 값도 바뀌게 되는 것이다.
     
     
     **** 참조 관계를 끊는법 *****
     1. var colors= candycolor.slice();

     1.5 Object.assign(obj2,obj);

     2.한개씩 넣어주는 방법(현실적으로 어려운...ㅋ)
     var obj={a:1,b:2}
     var obj2={}
     obj2.a=obj.a;
     obj2.b=obj.b;
     3.      1단계만 복사 나머지는 참조됨
       var obj={a:1,b:2,c:3}
       var obj2={};

         object.keys(obj)이렇게하면 obj의 키(key)만 뽑아낼수 있는데....

       object.keys(obj).forEach(function(key)){
           obj2[key]=obj[key];
       });  -> 단점이있음->


       사실 slice()메소드가 내부적으로 쓰는 방법이다.

       var obj={a:1, b:{c:1 } } 계층구조일때....
       var obj2={};

       object.keys(obj).forEach(function(key)){
           obj2[key]=obj[key];
       });  -> 
       obj2.a = 5; 값을 바꿨다
       obj.a = 1이 나와서 참조관계가 아닌것을 알수있다.
       하지만
       obj2.b.c=8;로 값을 바꿨을때
       obj.b.c 의 값은????? 1이 나와야 되는데....
       obj.b.c의 값이 8로 바뀌는 것을 볼수있는것이다. 
       a는 복사,b는 참조가 되는 경우가 생길수있다.

       이유???

       var obj={a:1, b:{c:1 } } 계층구조일때....
       var obj2={};
       일때
        object.keys(obj).forEach(function(key)){
           obj2[key]=obj[key];
       }); 
       이 forEach문을 풀어보면
       obj2.a = obj.a;
       obj2.b = obj.b;
       되는데 a는 복사 b는 객체형태이므로 참조관계가 됨을 알수있다.

       얕은복사 ==> 참조
       깊은복사 ==> 복사
       라고 이야기 하는것을 볼수있다.

       functoin copyObj(obj){
           var copy = {};
           if(typeof obj === 'object' && obj !== null){
               for(var attr in obj){
                   if(obj.hasOwnProperty(attr)){
                       copy[attr]=copyObj(obj[attr]);
                   }
               }
           }else{
               copy = obj;
           }
           return copy;
       }

       obj2= copyObj(obj);

       이렇게 하면 참조관계가 확실히 끊어지는것(깊은복사)을 알수있다.
       

       4.  var obj={a:1, b:{ c:1 } } 계층구조일때....
           var obj2={};
           obj2 = JSON.parse(JSON.stringify(obj));

           3번의 복잡하고 약간의문제? 점을 개선한 해결법이다.
           이걸 쓰자....성능이 최악이란다...지랄...아낙...
           prototype에서 쓰면 문제가 생긴다.




       *****  참조관계인지 아닌지 판별하는 방법 ******
       참조관계:
        var candycolor=['red','red','orange','orange','green','green','yellow','yellow','white','white','pink','pink'];
        var colors=candycolor;

        colors===candycolor => true 이면 참조관계



*/

-->